서울에서 김서방 찾기

문제 설명

String형 배열 seoul의 element중 Kim의 위치 x를 찾아, 김서방은 x에 있다는 String을 반환하는 함수, solution을 완성하세요. seoul에 Kim은 오직 한 번만 나타나며 잘못된 값이 입력되는 경우는 없습니다.
제한 조건

seoul은 길이 1 이상, 1000 이하인 배열입니다.
seoul의 원소는 길이 1 이상, 20 이하인 문자열입니다.
Kim은 반드시 seoul 안에 포함되어 있습니다.
입출력의 예
seoul	return
["Jane", "Kim"]	"김서방은 1에 있다"

나의 문제풀이

function solution(seoul) {
for(let i =0; i <seoul.length; i++) { 
If (seoul[i] === 'Kim')
Return `김서방은 ${i}에 있다`
}
}
seoul 배열의 길이만큼 for 문을 사용해서 배열 element를 하나하나를 돌면서 ‘kim’을 찾았을 때 index를 반환해서 문제를 풀었다.
다른 사람의 풀이

function findKim(seoul){
var idx = seoul.indexOf('Kim');
return "김서방은 " + idx + "에 있다";
}
seoul에 Kim은 오직 한 번만 나오며, Kim은 반드시 seoul 안에 포함되어 있기 때문에 indexOf 메소드를 사용해서 문제를 풀 수 있었다.
indexOf 메소드는 배열 내의 요소의 최초의 인덱스를 반환한다.발견되지 않으면 -1을 반환한다.


• 문자열 다루기 기본
문제설명
문자열 s의 길이가 4 혹은 6이고, 숫자로만 구성돼있는지 확인해주는 함수, solution을 완성하세요. 예를 들어 s가 "a234"이면 False를 리턴하고 "1234"라면 True를 리턴하면 됩니다.
제한사항
	• s는 길이 1 이상, 길이 8 이하인 문자열입니다.
입출력 예
s	return
"a234"	false
"1234"	true

작성한 코드

Function solution(s) { return (s.length === 4 || s.length === 6) && s == parseInt(s) }

==='가 아닌 '=='를 사용한 이유
	• '==' 서로 다른 유형의 두 변수의 값만 비교 (값 -> true) | 자료형은 판단하지 않는다
	• '===' 더 엄격하게 비교 (값 & 자료형 -> true) | 권장사항

• 완주하지 못한 선수
문제 설명
수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.
마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.
제한사항
	• 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.
	• completion의 길이는 participant의 길이보다 1 작습니다.
	• 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.
	• 참가자 중에는 동명이인이 있을 수 있습니다.

입출력 예
participant	completion	return
["leo", "kiki", "eden"]	["eden", "kiki"]	"leo"
["marina", "josipa", "nikola", "vinko", "filipa"]	["josipa", "filipa", "marina", "nikola"]	"vinko"
["mislav", "stanko", "mislav", "ana"]	["stanko", "ana", "mislav"]	"mislav"
입출력 예 설명
예제 #1
"leo"는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.
예제 #2
"vinko"는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.
예제 #3
"mislav"는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다.

정답코드
function solution(participant, completion) {
    participant.sort();
    completion.sort();
    for (let i = 0; i < participant.length; i++) {
        if(participant[i] !== completion[i]) {
            return participant[i]
        }
    }
}



